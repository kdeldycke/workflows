---
name: Docs
"on":
  workflow_call:
    inputs:
      dependency-graph-output:
        description: 'Location in the repository of the dependency graph image'
        default: './docs/images/dependencies.png'
        required: false
        type: string
  push:
    branches:
      - main
    # Triggers on tags for dependency graph updates.
    tags:

concurrency:
  # Group workflow jobs so new commits cancels in-progress execution triggered by previous commits.
  # Source: https://mail.python.org/archives/list/pypa-committers@python.org/thread/PCBCQMJF64JGRBOX7E2EE4YLKHT4DI55/
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:

  autofix-typo:
    name: Fix typos
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v3.0.2
      - uses: sobolevn/misspell-fixer-action@0.1.0
      - uses: peter-evans/create-pull-request@v4.0.4
        with:
          # WORKFLOW_UPDATE_GITHUB_PAT is a custom token created from my user's profile via the
          # "Developer Settings > Personal Access Tokens" UI to allow this job to update its own workflows. This is
          # only used on the original kdeldycke/workflows repository, hence the fallback to default GitHub token.
          token: ${{ secrets.WORKFLOW_UPDATE_GITHUB_PAT || secrets.GITHUB_TOKEN }}
          assignees: ${{ github.actor }}
          commit-message: "[autofix] Typo"
          title: "[autofix] Typo"
          body: >
            <details><summary><code>Workflow metadata</code></summary>


            > [Auto-generated on run `#${{ github.run_id }}`](${{ github.event.repository.html_url }}/actions/runs/${{
            github.run_id }}) by `${{ github.job }}` job from [`docs.yaml`](${{ github.event.repository.html_url
            }}/blob/${{ github.sha }}/.github/workflows/docs.yaml) workflow.


            </details>
          labels: "ðŸ“š documentation"
          branch: autofix-typo

  optimize-images:
    name: Optimize images
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v3.0.2
      # XXX calibreapp/image-actions has not been tagged for a while... :(
      - uses: calibreapp/image-actions@a6fb564733713b0120e56887426c4f5cb8fcbe69
        id: image_actions
        with:
          githubToken: ${{ secrets.GITHUB_TOKEN }}
          compressOnly: true
      - uses: peter-evans/create-pull-request@v4.0.4
        with:
          assignees: ${{ github.actor }}
          commit-message: "[autofix] Optimize images"
          title: "[autofix] Optimize images"
          body: >
            ${{ steps.image_actions.outputs.markdown }}


            <details><summary><code>Workflow metadata</code></summary>


            > [Auto-generated on run `#${{ github.run_id }}`](${{ github.event.repository.html_url }}/actions/runs/${{
            github.run_id }}) by `${{ github.job }}` job from [`docs.yaml`](${{ github.event.repository.html_url
            }}/blob/${{ github.sha }}/.github/workflows/docs.yaml) workflow.


            </details>
          labels: "ðŸ“š documentation"
          branch: optimize-images

  check-mailmap:
    name: Does .mailmap exist?
    runs-on: ubuntu-20.04
    outputs:
      exists: ${{ steps.detection.outputs.exists }}
    steps:
      - uses: actions/checkout@v3.0.2
      - id: detection
        run: |
          echo "::set-output name=exists::$( [[ -f './.mailmap' ]] && echo 'true' )"
      - name: Detection results
        run: |
          echo "Does .mailmap exist at root? ${{ steps.detection.outputs.exists && true || false  }}"

  update-mailmap:
    name: Update .mailmap
    needs:
      - check-mailmap
    # Only update mailmap if a file is found at the root of repository.
    if: needs.check-mailmap.outputs.exists
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v3.0.2
        with:
          # Fetch all history to extract all contributors.
          fetch-depth: 0
      - uses: actions/setup-python@v4.2.0
        with:
          python-version: "3.10"
      - name: Generate .mailmap
        run: >
          python -c "$(curl -fsSL
          https://raw.githubusercontent.com/kdeldycke/workflows/main/.github/update_mailmap.py)"
      - uses: peter-evans/create-pull-request@v4.0.4
        with:
          assignees: ${{ github.actor }}
          commit-message: "[autofix] Update .mailmap"
          title: "[autofix] Update .mailmap"
          body: >
            <details><summary><code>Workflow metadata</code></summary>


            > [Auto-generated on run `#${{ github.run_id }}`](${{ github.event.repository.html_url }}/actions/runs/${{
            github.run_id }}) by `${{ github.job }}` job from [`docs.yaml`](${{ github.event.repository.html_url
            }}/blob/${{ github.sha }}/.github/workflows/docs.yaml) workflow.


            </details>
          labels: "ðŸ“š documentation"
          branch: update-mailmap

  # TODO: Deduplicate with the step from autofix.yaml and release.yaml
  poetry-metadata:
    name: Poetry metadata
    runs-on: ubuntu-20.04
    outputs:
      is_poetry: ${{ steps.detection.outputs.is_poetry }}
      package_name: ${{ steps.extract_name.outputs.package_name }}
      # Mypy needs to be fed with this parameter:
      #   --python-version x.y
      # Proposed upstream (but rejected) at: https://github.com/python/mypy/issues/13294
      mypy_params: ${{ steps.py_versions.outputs.mypy_params }}
      # Black should be fed with a subset of these parameters:
      #   --target-version py33
      #   --target-version py34
      #   --target-version py35
      #   --target-version py36
      #   --target-version py37
      #   --target-version py38
      #   --target-version py39
      #   --target-version py310
      #   --target-version py311
      # "You should include all Python versions that you want your code to run under.",
      # as per: https://github.com/psf/black/issues/751
      # Currently being discussed upstream at: https://github.com/psf/black/issues/3124
      black_params: ${{ steps.py_versions.outputs.black_params }}
      # Pyupgrade needs to be fed with one of these parameters:
      #   --py3-plus
      #   --py36-plus
      #   --py37-plus
      #   --py38-plus
      #   --py39-plus
      #   --py310-plus
      #   --py311-plus
      # Proposed upstream (but rejected) at: https://github.com/asottile/pyupgrade/issues/688
      pyupgrade_params: ${{ steps.py_versions.outputs.pyupgrade_params }}
    steps:
      - uses: actions/checkout@v3.0.2
      - id: detection
        run: |
          echo "::set-output name=is_poetry::$( [[ -f 'pyproject.toml' && -f 'poetry.lock' ]] && echo 'true' )"
      - name: Install tomli
        if: steps.detection.outputs.is_poetry
        run: >
          python -m pip install --requirement
          https://raw.githubusercontent.com/kdeldycke/workflows/main/requirements.txt
      - name: Extract package name
        if: steps.detection.outputs.is_poetry
        id: extract_name
        shell: python
        run: |
          from pathlib import Path

          import sys

          if sys.version_info >= (3, 11):
              import tomllib
          else:
              import tomli as tomllib

          # Locate and loads pyproject.toml.
          toml_path = Path("./pyproject.toml")
          toml_config = tomllib.loads(toml_path.read_text())

          package_name = toml_config["tool"]["poetry"]["name"]

          if package_name:
              print(f"::set-output name=package_name::{package_name}")
      - name: Python versions for black, mypy and pyupgrade
        if: steps.detection.outputs.is_poetry
        id: py_versions
        shell: python
        run: |
          from pathlib import Path

          from poetry.core.pyproject.toml import PyProjectTOML
          from poetry.core.semver import parse_constraint

          pyproject = PyProjectTOML(Path("./pyproject.toml"))
          min_version = parse_constraint(pyproject.poetry_config["dependencies"]["python"]).min

          # Generate mypy parameter.
          print(f"::set-output name=mypy_params::--python-version {min_version.major}.{min_version.minor}")

          # Generate black parameters.
          black_params = []
          if min_version.major == 3 and min_version.minor >= 3:
              for minor in range(min_version.minor, 11 + 1):
                  black_params.append(f"--target-version py3{minor}")
          print(f"::set-output name=black_params::{' '.join(black_params)}")

          # Generate pyupgrade parameter.
          pyupgrade_param = ""
          if min_version.major == 3:
              minor_version = ""
              if min_version.minor >= 6:
                  minor_version = min_version.minor
              pyupgrade_param = f"--py3{minor_version}-plus"
          print(f"::set-output name=pyupgrade_params::{pyupgrade_param}")
      - name: Metadata results
        run: |
          echo "Is project poetry-based? ${{ steps.detection.outputs.is_poetry && true || false }}"
          echo "Package name: ${{ steps.extract_name.outputs.package_name }}"
          echo "Mypy parameters: ${{ steps.py_versions.outputs.mypy_params }}"
          echo "Black parameters: ${{ steps.py_versions.outputs.black_params }}"
          echo "Pyupgrade parameters: ${{ steps.py_versions.outputs.pyupgrade_params }}"

  update-deps-graph:
    name: Update dependency image and create a PR
    needs:
      - poetry-metadata
    if: needs.poetry-metadata.outputs.is_poetry && needs.poetry-metadata.outputs.package_name
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v3.0.2
      - uses: actions/setup-python@v4.2.0
        with:
          python-version: "3.10"
      - name: Install pip and Poetry
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade poetry
      - name: Install pipdeptree
        run: >
          python -m pip install --requirement
          https://raw.githubusercontent.com/kdeldycke/workflows/main/requirements.txt
      - name: Install Graphviz
        run: |
          sudo apt install graphviz
      - name: Run pipdeptree
        run: >
          pipdeptree
          --packages ${{ needs.poetry-metadata.outputs.package_name }}
          --graph-output png > ${{ inputs.dependency-graph-output || './docs/images/dependencies.png' }}
      - uses: peter-evans/create-pull-request@v4.0.4
        # Only triggers on version tagging.
        if: startsWith(github.ref, 'refs/tags/v')
        with:
          assignees: ${{ github.actor }}
          commit-message: "[autofix] Regenerate dependency graph"
          title: "[autofix] Regenerate dependency graph"
          body: >
            <details><summary><code>Workflow metadata</code></summary>


            > [Auto-generated on run `#${{ github.run_id }}`](${{ github.event.repository.html_url }}/actions/runs/${{
            github.run_id }}) by `${{ github.job }}` job from [`docs.yaml`](${{ github.event.repository.html_url
            }}/blob/${{ github.sha }}/.github/workflows/docs.yaml) workflow.


            </details>
          labels: "ðŸ“š documentation"
          branch: update-deps-graph

  is-sphinx:
    name: Is doc Sphinx-based?
    runs-on: ubuntu-20.04
    outputs:
      is_sphinx: ${{ steps.detection.outputs.is_sphinx }}
      active_autodoc: ${{ steps.detection.outputs.active_autodoc }}
    steps:
      - uses: actions/checkout@v3.0.2
      - id: detection
        shell: python
        run: |
          import ast
          from pathlib import Path

          conf_path = Path() / "docs" / "conf.py"

          if conf_path.exists() and conf_path.is_file():
              # We found the Sphinx config file, that's enought for us.
              print(f"::set-output name=is_sphinx::true")

              # Look for list of active Sphinx extensions.
              for node in ast.parse(conf_path.read_bytes()).body:
                  if isinstance(node, ast.Assign) and isinstance(node.value, (ast.List, ast.Tuple)):
                      extension_found = "extensions" in (t.id for t in node.targets)
                      if extension_found:
                          elements = [e.value for e in node.value.elts if isinstance(e, ast.Constant)]
                          if "sphinx.ext.autodoc" in elements:
                              print(f"::set-output name=active_autodoc::true")
                          break
      - name: Detection results
        run: |
          echo "Is doc Sphinx-based? ${{ steps.detection.outputs.is_sphinx && true || false }}"
          echo "Is autodoc extension active? ${{ steps.detection.outputs.active_autodoc && true || false }}"

  update-autodoc:
    name: Update autodoc
    needs:
      - poetry-metadata
      - is-sphinx
    if: needs.poetry-metadata.outputs.is_poetry && needs.is-sphinx.outputs.active_autodoc
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v3.0.2
      - uses: actions/setup-python@v4.2.0
        with:
          python-version: "3.10"
      - name: Install Sphinx
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade poetry
          poetry install --no-interaction --no-ansi
      - name: Run Sphinx
        run: |
          poetry run sphinx-apidoc -f -o ./docs .
      - uses: peter-evans/create-pull-request@v4.0.4
        with:
          assignees: ${{ github.actor }}
          commit-message: "[autofix] Update Sphinx autodoc"
          title: "[autofix] Update Sphinx autodoc"
          body: >
            <details><summary><code>Workflow metadata</code></summary>


            > [Auto-generated on run `#${{ github.run_id }}`](${{ github.event.repository.html_url }}/actions/runs/${{
            github.run_id }}) by `${{ github.job }}` job from [`docs.yaml`](${{ github.event.repository.html_url
            }}/blob/${{ github.sha }}/.github/workflows/docs.yaml) workflow.


            </details>
          labels: "ðŸ“š documentation"
          branch: update-autodoc

  deploy-docs:
    name: Deploy Sphinx doc
    needs:
      - poetry-metadata
      - is-sphinx
    if: needs.poetry-metadata.outputs.is_poetry && needs.is-sphinx.outputs.is_sphinx
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v3.0.2
      - uses: actions/setup-python@v4.2.0
        with:
          python-version: "3.10"
      - name: Install Sphinx
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade poetry
          # Let sphinx-click access project's code to generate CLI help.
          poetry config virtualenvs.create false
          poetry install --no-interaction --no-ansi
      - name: Build documentation
        run: |
          poetry run sphinx-build -b html ./docs ./docs/html
      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3.8.0
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/html
          force_orphan: true