---
name: Build & release
# Read https://github.com/actions/runner/issues/491 for insights on complex workflow execution logic.
"on":
  workflow_call:
    secrets:
      PYPI_TOKEN:
        required: false
    outputs:
      tagged_version:
        description: Tagged/released version (without leading 'v')
        value: ${{ jobs.git-tag.outputs.tagged_version }}
  # Target are chosen so that all commits get a chance to have their build tested.
  push:
    branches:
      - main
  pull_request:

jobs:

  commit-matrix:
    name: List new and releases commits
    runs-on: ubuntu-20.04
    outputs:
        # There's a design issue with GitHub actions: matrix outputs are not cumulative. The last job wins.
        # See: https://github.community/t/bug-jobs-output-should-return-a-list-for-a-matrix-job/128626
        # So we will use this step to list all commits by category.
      new_commits_matrix: ${{ steps.new_commits_matrix.outputs.matrix }}
      release_commits_matrix: ${{ steps.release_commits_matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v3.0.2
        with:
          # Checkout pull request HEAD commit to ignore actions/checkout's merge commit. Fallback to push SHA.
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          # We're going to browse all new commits.
          fetch-depth: 0
      - name: List all branches
        run: |
          git branch --all
      - name: List all commits
        run: |
          git log --decorate=full --oneline
      - name: Get commit range
        id: commit_range
        # New commits needs to be fetched differently in push and pull_requests events. Sources:
        #   * https://stackoverflow.com/a/67204539
        #   * https://stackoverflow.com/a/62953566
        #   * https://stackoverflow.com/a/61861763
        run: |
          if [ $GITHUB_BASE_REF ]; then
            # Pull request event, for which we need to checkout the HEAD commit instead of the artificial merge commit.
            COMMIT_RANGE="origin/${{ github.base_ref }}..${{ github.event.pull_request.head.sha }}"
          else
            # Push event.
            COMMIT_RANGE="${{ github.event.before }}..${{ github.sha }}"
          fi
          echo "::set-output name=range::$COMMIT_RANGE"
      - name: List new commits
        id: new_commits
        # Here's a trick to encode "\n" before using the "::set-output" directive:
        # https://github.community/t/set-output-truncates-multiline-strings/16852/3
        run: |
          COMMITS=$( git rev-list ${{ steps.commit_range.outputs.range }} -- )
          COMMITS="${COMMITS//$'\n'/'%0A'}"
          echo "::set-output name=commits::$COMMITS"
      - name: List release commits
        id: release_commits
        # Same as new_commits step, but with "--grep" option.
        run: |
          COMMITS=$( \
            git rev-list -E --grep="^\[changelog\] Release v[0-9]+\.[0-9]+\.[0-9]+$" \
            ${{ steps.commit_range.outputs.range }} -- )
          COMMITS="${COMMITS//$'\n'/'%0A'}"
          echo "::set-output name=commits::$COMMITS"
      - name: Print commits
        run: |
          echo -e "New commits:\n${{ steps.new_commits.outputs.commits }}"
          echo "---"
          echo -e "Release commits:\n${{ steps.release_commits.outputs.commits }}"
      - name: Create JSON new commits matrix
        id: new_commits_matrix
        if: steps.new_commits.outputs.commits
        # Source: https://stackoverflow.com/a/44477891
        run: >
          echo "::set-output name=matrix::$(
          echo '${{ steps.new_commits.outputs.commits }}'
          | jq -R -s -c 'split("\n") | map(select(length > 0)) | {commit: .}'
          )"
      - name: Create JSON release commits matrix
        id: release_commits_matrix
        if: steps.release_commits.outputs.commits
        run: >
          echo "::set-output name=matrix::$(
          echo '${{ steps.release_commits.outputs.commits }}'
          | jq -R -s -c 'split("\n") | map(select(length > 0)) | {commit: .}'
          )"
      - name: Print JSON of new commits
        # Print raw string and parsed JSON.
        run: |
          echo '${{ steps.new_commits_matrix.outputs.matrix }}'
          jq -aR <<< echo '${{ steps.new_commits_matrix.outputs.matrix }}'
      - name: Print JSON of release commits
        run: |
          echo '${{ steps.release_commits_matrix.outputs.matrix }}'
          jq -aR <<< echo '${{ steps.release_commits_matrix.outputs.matrix }}'

  # TODO: Deduplicate with the step from autofix.yaml and docs.yaml
  poetry-metadata:
    name: Poetry metadata
    runs-on: ubuntu-20.04
    outputs:
      is_poetry: ${{ steps.detection.outputs.is_poetry }}
      package_name: ${{ steps.extract_name.outputs.package_name }}
      # Mypy needs to be fed with this parameter:
      #   --python-version x.y
      # Proposed upstream (but rejected) at: https://github.com/python/mypy/issues/13294
      mypy_params: ${{ steps.py_versions.outputs.mypy_params }}
      # Black should be fed with a subset of these parameters:
      #   --target-version py33
      #   --target-version py34
      #   --target-version py35
      #   --target-version py36
      #   --target-version py37
      #   --target-version py38
      #   --target-version py39
      #   --target-version py310
      #   --target-version py311
      # "You should include all Python versions that you want your code to run under.",
      # as per: https://github.com/psf/black/issues/751
      # Currently being discussed upstream at: https://github.com/psf/black/issues/3124
      black_params: ${{ steps.py_versions.outputs.black_params }}
      # Pyupgrade needs to be fed with one of these parameters:
      #   --py3-plus
      #   --py36-plus
      #   --py37-plus
      #   --py38-plus
      #   --py39-plus
      #   --py310-plus
      #   --py311-plus
      # Proposed upstream (but rejected) at: https://github.com/asottile/pyupgrade/issues/688
      pyupgrade_params: ${{ steps.py_versions.outputs.pyupgrade_params }}
    steps:
      - uses: actions/checkout@v3.0.2
      - id: detection
        run: |
          echo "::set-output name=is_poetry::$( [[ -f 'pyproject.toml' && -f 'poetry.lock' ]] && echo 'true' )"
      - name: Install tomli
        if: steps.detection.outputs.is_poetry
        run: >
          python -m pip install --requirement
          https://raw.githubusercontent.com/kdeldycke/workflows/main/requirements.txt
      - name: Extract package name
        if: steps.detection.outputs.is_poetry
        id: extract_name
        shell: python
        run: |
          from pathlib import Path

          import sys

          if sys.version_info >= (3, 11):
              import tomllib
          else:
              import tomli as tomllib

          # Locate and loads pyproject.toml.
          toml_path = Path("./pyproject.toml")
          toml_config = tomllib.loads(toml_path.read_text())

          package_name = toml_config["tool"]["poetry"]["name"]

          if package_name:
              print(f"::set-output name=package_name::{package_name}")
      - name: Python versions for black, mypy and pyupgrade
        if: steps.detection.outputs.is_poetry
        id: py_versions
        shell: python
        run: |
          from pathlib import Path

          from poetry.core.pyproject.toml import PyProjectTOML
          from poetry.core.semver import parse_constraint

          pyproject = PyProjectTOML(Path("./pyproject.toml"))
          min_version = parse_constraint(pyproject.poetry_config["dependencies"]["python"]).min

          # Generate mypy parameter.
          print(f"::set-output name=mypy_params::--python-version {min_version.major}.{min_version.minor}")

          # Generate black parameters.
          black_params = []
          if min_version.major == 3 and min_version.minor >= 3:
              for minor in range(min_version.minor, 11 + 1):
                  black_params.append(f"--target-version py3{minor}")
          print(f"::set-output name=black_params::{' '.join(black_params)}")

          # Generate pyupgrade parameter.
          pyupgrade_param = ""
          if min_version.major == 3:
              minor_version = ""
              if min_version.minor >= 6:
                  minor_version = min_version.minor
              pyupgrade_param = f"--py3{minor_version}-plus"
          print(f"::set-output name=pyupgrade_params::{pyupgrade_param}")
      - name: Metadata results
        run: |
          echo "Is project poetry-based? ${{ steps.detection.outputs.is_poetry && true || false }}"
          echo "Package name: ${{ steps.extract_name.outputs.package_name }}"
          echo "Mypy parameters: ${{ steps.py_versions.outputs.mypy_params }}"
          echo "Black parameters: ${{ steps.py_versions.outputs.black_params }}"
          echo "Pyupgrade parameters: ${{ steps.py_versions.outputs.pyupgrade_params }}"

  poetry-build:
    name: "Poetry: build & check package"
    needs:
      - commit-matrix
      - poetry-metadata
    if: needs.poetry-metadata.outputs.is_poetry
    strategy:
      matrix: ${{ fromJson(needs.commit-matrix.outputs.new_commits_matrix) }}
    runs-on: ubuntu-20.04
    steps:
      - name: Print target commit
        run: |
          echo "${{ matrix.commit }}"
      - uses: actions/checkout@v3.0.2
        with:
          ref: ${{ matrix.commit }}
      - uses: actions/setup-python@v4.2.0
        with:
          python-version: "3.10"
      - name: Install pip and Poetry
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade poetry
      - name: Build package
        run: |
          poetry install --no-interaction --no-ansi
          poetry build --no-interaction --no-ansi
      - name: Artifacts for GitHub release
        uses: actions/upload-artifact@v3.1.0
        with:
          name: ${{ github.event.repository.name }}-build-${{ matrix.commit }}
          path: ./dist/*
      - name: Install twine and check-wheel-contents
        run: >
          python -m pip install --requirement
          https://raw.githubusercontent.com/kdeldycke/workflows/main/requirements.txt
      - name: Validates package metadata
        run: |
          poetry check --no-interaction --no-ansi
          poetry run twine check ./dist/*
          poetry run check-wheel-contents ./dist/*.whl
      - name: Test publishing
        run: |
          poetry publish --dry-run --no-interaction

  git-tag:
    name: Tag release
    needs:
      - commit-matrix
    # Only consider pushes to main branch as triggers for releases.
    if: github.ref == 'refs/heads/main' && needs.commit-matrix.outputs.release_commits_matrix
    strategy:
      matrix: ${{ fromJson(needs.commit-matrix.outputs.release_commits_matrix) }}
    runs-on: ubuntu-20.04
    outputs:
      tagged_version: ${{ steps.get_version.outputs.tagged_version }}
    steps:
      - name: Print release commit
        run: |
          echo "${{ matrix.commit }}"
      - uses: actions/checkout@v3.0.2
        with:
          ref: ${{ matrix.commit }}
      - name: Extract version
        id: get_version
        run: >
          echo "::set-output name=tagged_version::$( grep "current_version = " ./.bumpversion.cfg | cut -d ' ' -f 3 )"
      - name: Print version
        run: |
          echo "Tagged version: ${{ steps.get_version.outputs.tagged_version }}"
      - id: tag_exists
        run: |
          echo "::set-output name=tag_exists::$(
          git show-ref --tags "v${{ steps.get_version.outputs.tagged_version }}" --quiet )"
      - name: Tag search results
        run: |
          echo "Does tag exist? ${{ steps.tag_exists.outputs.tag_exists && true || false }}"
      - name: Push tag
        # If for whatever reason the workflow is re-run because it failed the first time, just
        # skip the tag creation if it already exists.
        if: ${{ ! steps.tag_exists.outputs.tag_exists }}
        uses: tvdias/github-tagger@v0.0.2
        with:
          repo-token: ${{ secrets.WORKFLOW_UPDATE_GITHUB_PAT || secrets.GITHUB_TOKEN }}
          tag: v${{ steps.get_version.outputs.tagged_version }}
          commit-sha: ${{ matrix.commit }}

  pypi-publish:
    name: Publish to PyPi
    needs:
      - commit-matrix
      - poetry-metadata
      - poetry-build
      - git-tag
    strategy:
      matrix: ${{ fromJson(needs.commit-matrix.outputs.release_commits_matrix) }}
    runs-on: ubuntu-20.04
    outputs:
      release_text: ${{ steps.generate_text.outputs.release_text }}
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v3.0.0
        id: download
        with:
          name: ${{ github.event.repository.name }}-build-${{ matrix.commit }}
      - name: Push package to public PyPi repository
        uses: pypa/gh-action-pypi-publish@v1.5.1
        with:
          user: __token__
          password: ${{ secrets.PYPI_TOKEN }}
          packages_dir: ${{ steps.download.outputs.download-path }}
      - name: Generate release text
        id: generate_text
        run: >
          echo "::set-output name=release_text::[🐍
          Available on PyPi](https://pypi.org/project/${{ needs.poetry-metadata.outputs.package_name }}/${{
          needs.git-tag.outputs.tagged_version }})"

  github-release:
    name: Publish GitHub release
    needs:
      - commit-matrix
      - git-tag
      - pypi-publish
    # Make sure this job always starts if git-tag ran and succeeded.
    if: always() && needs.git-tag.result == 'success'
    strategy:
      matrix: ${{ fromJson(needs.commit-matrix.outputs.release_commits_matrix) }}
    runs-on: ubuntu-20.04
    steps:
      - name: Download build artifacts
        # Do not try to fetch build artifacts if the publishing step has been skipped.
        if: needs.pypi-publish.result != 'skipped'
        uses: actions/download-artifact@v3.0.0
        id: download
        with:
          name: ${{ github.event.repository.name }}-build-${{ matrix.commit }}
      - name: Create a release on GitHub
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.git-tag.outputs.tagged_version }}
          target_commitish: ${{ matrix.commit }}
          files: ${{ steps.download.outputs.download-path }}/*
          body: |
            ${{ needs.pypi-publish.outputs.release_text }}
