---
name: Build & release
# Read https://github.com/actions/runner/issues/491 for insights on complex workflow execution logic.
"on":
  workflow_call:
    secrets:
      PYPI_TOKEN:
        required: false
    outputs:
      tagged_version:
        description: Tagged/released version (without leading 'v')
        value: ${{ jobs.git-tag.outputs.tagged_version }}
  # Target all push so any commit will get a chance to have their build tested.
  push:
    # Only trigger on branches, not on tags.
    branches:
      - '**'
    #   - main

jobs:

  generate-commit-matrix:
    name: Get all push's commits
    runs-on: ubuntu-20.04
    outputs:
      matrix: "{\"commit\": ${{ steps.generate_matrix.outputs.all_commits }} }"
    steps:
      - run: |
          sudo apt update
          sudo apt install -y jq
      - uses: actions/checkout@v2
        with:
          # We're going to browse all new commits.
          fetch-depth: 0
      - name: List all branches
        run: |
          git branch --all
      - name: List previous commits
        run: |
          git log --decorate=full --oneline
      - name: Fetch all new commits
        id: generate_matrix
        # Sources:
        #   https://stackoverflow.com/a/67204539
        #   https://stackoverflow.com/a/44477891
        run: |
          NEW_COMMITS=$( git rev-list ${{ github.event.before }}..${{ github.sha }} )
          echo "$NEW_COMMITS"
          JSON_MATRIX=$( echo "$NEW_COMMITS" | jq -R -s -c 'split("\n") | map(select(length>0)) | "{\"commit\": \(.) }"' )
          echo "::set-output name=all_commits:: $( $JSON_MATRIX )"
      - name: Print new commits
        run: |
          echo "${{ steps.generate_matrix.outputs.all_commits }}"

  test-matrix:
    name: Run job on ${{ matrix.commit }} commit
    runs-on: ubuntu-20.04
    needs: generate-commit-matrix
    strategy:
      matrix: ${{ fromJson(needs.generate-commit-matrix.outputs.matrix) }}
    steps:
      - name: Print target commit
        run: |
          echo "${{ matrix.commit }}"
      - uses: actions/checkout@v2
        with:
          ref: ${{ matrix.commit }}
      - name: List all branches
        run: |
          git branch --all
      - name: List previous commits
        run: |
          git log --decorate=full --oneline

  prepare-release-merged:
    name: prepare-release PR merged
    # Creates a git tag when the prepare-release PR has been merged to main branch.
    if: github.head_ref == 'prepare-release' && github.event.pull_request.merged
    runs-on: ubuntu-20.04
    steps:
      - uses: crazy-max/ghaction-dump-context@v1.2.0

  is-poetry-based:
    name: Is project Poetry-based?
    runs-on: ubuntu-20.04
    outputs:
      is_poetry: ${{ steps.poetry_detection.outputs.is_poetry }}
    steps:
      - uses: actions/checkout@v2.4.0
      - id: poetry_detection
        run: |
          echo "::set-output name=is_poetry::$( [[ -f 'pyproject.toml' && -f 'poetry.lock' ]] && echo 'true' )"

  poetry-build:
    name: "Poetry: build & check package"
    needs: is-poetry-based
    if: needs.is-poetry-based.outputs.is_poetry
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2.4.0
      - uses: actions/setup-python@v2.3.1
      - name: Install pip and Poetry
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade poetry
      - name: Build package
        run: |
          poetry install --no-interaction --no-ansi
          poetry build --no-interaction --no-ansi
      - name: Extract version
        id: get_version
        run: |
          echo "::set-output name=tagged_version::$( poetry version --short )"
      - name: Artefacts for GitHub release
        uses: actions/upload-artifact@v2.3.1
        with:
          name: ${{ github.event.repository.name }}-builds-v${{ steps.get_version.outputs.tagged_version }}
          path: ./dist/*
      - name: Install twine and check-wheel-contents
        run: >
          python -m pip install --requirement
          https://raw.githubusercontent.com/kdeldycke/workflows/main/requirements.txt
      - name: Validates package metadata
        run: |
          poetry check --no-interaction --no-ansi
          poetry run twine check ./dist/*
          poetry run check-wheel-contents ./dist/*.whl
      - name: Test publishing
        run: |
          poetry publish --dry-run --no-interaction

  git-tag:
    name: Tag release
    needs: prepare-release-merged
    runs-on: ubuntu-20.04
    outputs:
      tagged_version: ${{ steps.get_version.outputs.tagged_version }}
    steps:
      - uses: actions/checkout@v2.4.0
        with:
          ref: main
          # Get a couple of previous commits to trace back to the start of the PR.
          fetch-depth: 10
      - name: List all branches
        run: |
          git branch --all
      - name: List previous commits
        run: |
          git log --decorate=full --oneline
      - name: Extract release commit
        id: get_release_commit
        run: |
          echo "::set-output name=tagged_sha::$(
          git log --all --grep='\[changelog\] Release v${{
          steps.get_version.outputs.tagged_version }}' | head -1 | cut -d ' ' -f 2 )"
      - name: Print first commit SHA
        run: |
          echo "${{ steps.get_release_commit.outputs.tagged_sha }}"
      - name: Checkout first commit
        run: |
          git checkout ${{ steps.get_release_commit.outputs.tagged_sha }}
      - name: Extract version
        id: get_version
        run: |
          echo "::set-output name=tagged_version::$( grep "current_version = " ./.bumpversion.cfg | cut -d ' ' -f 3 )"
      - name: Print version
        run: |
          echo "Tagged version: ${{ steps.get_version.outputs.tagged_version }}"
      - name: Push tag
        uses: tvdias/github-tagger@v0.0.2
        with:
          # XXX PAT token might be made optional if we tie the tagging job to a main branch push filtering on commit
          # message.
          repo-token: ${{ secrets.WORKFLOW_UPDATE_GITHUB_PAT || secrets.GITHUB_TOKEN }}
          tag: v${{ steps.get_version.outputs.tagged_version }}
          commit-sha: ${{ steps.get_release_commit.outputs.tagged_sha }}

  pypi-publish:
    name: Publish to PyPi
    needs:
      - git-tag
      - poetry-build
    runs-on: ubuntu-20.04
    steps:
      - name: Download build artefacts
        uses: actions/download-artifact@v2.1.0
        id: download
        with:
          name: ${{ github.event.repository.name }}-builds-v${{ needs.git-tag.outputs.tagged_version }}
      - name: Push package to public PyPi repository
        uses: pypa/gh-action-pypi-publish@v1.5.0
        with:
          user: __token__
          password: ${{ secrets.PYPI_TOKEN }}
          packages_dir: ${{ steps.download.outputs.download-path }}
      - name: Generate release text
        run: >
          echo "::set-output name=release-text::[üêç
          Available on PyPi](https://pypi.org/project/meta-package-manager/${{
          needs.git-tag.outputs.tagged_version }})"

  github-release:
    name: Publish GitHub release
    needs:
      - git-tag
      - pypi-publish
      # - *-publish
    # Make sure this job always start if git-tag is ran and succeed.
    if: always() && needs.git-tag.result == 'success'
    runs-on: ubuntu-20.04
    steps:
      - name: Download build artefacts
        # Do not try to fetch build artefacts if the publishing step has been skipped.
        if: needs.pypi-publish.result != 'skipped'
        uses: actions/download-artifact@v2.1.0
        id: download
        with:
          name: ${{ github.event.repository.name }}-builds-v${{ needs.git-tag.outputs.tagged_version }}
      - uses: actions/checkout@v2.4.0
        with:
          ref: v${{ needs.git-tag.outputs.tagged_version }}
      - name: Extract tagged commit SHA
        id: get_tagged_sha
        run: |
          echo "::set-output name=tagged_sha::$( git rev-parse v${{ needs.git-tag.outputs.tagged_version }} )"
      - name: Create a release on GitHub
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.git-tag.outputs.tagged_version }}
          target_commitish: ${{ steps.get_tagged_sha.outputs.tagged_sha }}
          files: ${{ steps.download.outputs.download-path }}
          body: |
            ${{ needs.pypi-publish.outputs.release-text }}